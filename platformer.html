<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini HTML Platformer</title>
  <style>
    /* Basic reset */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body { height: 100%; }
    body { display:flex; align-items:center; justify-content:center; background: linear-gradient(#87CEEB,#bfe9ff); font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial; }

    /* Game container */
    #game { width: 900px; max-width: 95vw; background: #7ec850; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.15); padding: 12px; }
    canvas { display:block; width:100%; height:480px; background: linear-gradient(#9ee57a,#49a23a); border-radius:6px; image-rendering: pixelated; }

    /* HUD */
    .hud { display:flex; justify-content:space-between; margin-top:8px; color:#083; font-weight:700; }
    .hud div { background: rgba(255,255,255,0.8); padding:6px 10px; border-radius:6px; }

    .credits { margin-top:8px; font-size:12px; text-align:center; color:#024; }

    /* Mobile controls hint */
    .controls { margin-top:8px; text-align:center; font-size:13px; color:#023; }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="c" width="960" height="540"></canvas>
    <div class="hud"><div id="score">Score: 0</div><div id="lives">Lives: 3</div></div>
    <div class="controls">Controls: ← → to move, Space to jump. Click on canvas to give keyboard focus.</div>
    <div class="credits">Simple single-file platformer — modify the <code>level</code> array in the code to build your own stages.</div>
  </div>

<script>
/*
  Mini platformer engine (single file)
  - Tilemap based level
  - Player physics (accel, friction, gravity, jump)
  - Simple enemy (patrol) & coins
  - Camera follow
  - Easy to extend
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
// Virtual resolution (game units)
const VW = 16; // tile size in pixels
const VIEW_W = canvas.width;
const VIEW_H = canvas.height;

// Input
const keys = {};
window.addEventListener('keydown', e => { keys[e.code]=true; if(['Space','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code]=false; });
canvas.addEventListener('mousedown', ()=> canvas.focus());

// Level legend
// 0 = empty, 1 = ground, 2 = platform (one-way), 3 = coin, 4 = enemy spawn, 5 = goal

const level = [
  // each inner array is a row, left-to-right. shorter rows will be padded with 0.
  // Build a long level by adding more columns.
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,4,0,1,0],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];
// Level dimensions
let ROWS = level.length;
let COLS = Math.max(...level.map(r => r.length));

// Expand rows to COLS
for(let r=0;r<ROWS;r++){
  while(level[r].length < COLS) level[r].push(0);
}

// Entities
class Player{
  constructor(x,y){
    this.x = x; this.y = y; // in pixels
    this.w = 34; this.h = 44;
    this.vx = 0; this.vy = 0;
    this.onGround = false;
    this.facing = 1;
    this.score = 0;
    this.lives = 3;
  }
}

class Enemy{
  constructor(x,y){ this.x=x; this.y=y; this.w=34; this.h=34; this.vx=60; }
}

const player = new Player(64, -100);
const enemies = [];
const coins = [];
let goal = null;

// Parse level for spawns
for(let r=0;r<ROWS;r++){
  for(let c=0;c<COLS;c++){
    const t = level[r][c];
    const px = c * VW;
    const py = r * VW;
    if(t===3) coins.push({x:px+VW/4,y:py+VW/4,w:VW/2,h:VW/2,collected:false});
    if(t===4) enemies.push(new Enemy(px, py - VW + 4));
    if(t===5) goal = {x:px, y:py - VW, w:VW, h:VW};
  }
}

// Physics params
const GRAVITY = 1600; // px/s^2
const MAX_FALL = 1000;
const MOVE_ACC = 2200; // px/s^2
const MAX_RUN = 280; // px/s
const FRICTION = 1800;
const JUMP_FORCE = 520;

// Camera
const cam = {x:0,y:0,w:VIEW_W,h:VIEW_H};

let last = performance.now();
let accumulator = 0;
const STEP = 1/120; // fixed step for physics

function tileAtPixel(px, py){
  if(px<0 || py<0) return 0;
  const c = Math.floor(px / VW);
  const r = Math.floor(py / VW);
  if(r>=ROWS || c>=COLS) return 0;
  return level[r][c] || 0;
}

function isSolidTile(t){ return t===1; }
function isPlatformTile(t){ return t===2; }

function resolveCollisions(entity, dt){
  // A simple AABB tile collider resolution
  // move on X
  entity.x += entity.vx * dt;
  const left = entity.x;
  const right = entity.x + entity.w;
  const top = entity.y;
  const bottom = entity.y + entity.h;

  // check horizontal collisions
  const samples = [top+2, bottom-2];
  for(const sy of samples){
    const txL = Math.floor(left / VW);
    const txR = Math.floor((right-1) / VW);
    const ty = Math.floor(sy / VW);
    for(let tx=txL; tx<=txR; tx++){
      if(ty<0 || ty>=ROWS || tx<0 || tx>=COLS) continue;
      const t = level[ty][tx];
      if(isSolidTile(t)){
        // resolve
        if(entity.vx > 0){
          entity.x = tx*VW - entity.w - 0.001;
        } else if(entity.vx < 0){
          entity.x = (tx+1)*VW + 0.001;
        }
        entity.vx = 0;
      }
    }
  }

  // move on Y
  entity.y += entity.vy * dt;

  const left2 = entity.x;
  const right2 = entity.x + entity.w;
  const top2 = entity.y;
  const bottom2 = entity.y + entity.h;

  const samplesY = [left2+2, right2-2];
  entity.onGround = false;
  for(const sx of samplesY){
    const tx = Math.floor(sx / VW);
    const tyTop = Math.floor(top2 / VW);
    const tyBottom = Math.floor((bottom2-1) / VW);
    for(let ty=tyTop; ty<=tyBottom; ty++){
      if(ty<0 || ty>=ROWS || tx<0 || tx>=COLS) continue;
      const t = level[ty][tx];
      if(isSolidTile(t) || (isPlatformTile(t) && entity.vy >=0 && (top2 < ty*VW))){
        // collided
        if(entity.vy > 0){
          // falling -> place on top
          entity.y = ty*VW - entity.h - 0.001;
          entity.vy = 0;
          entity.onGround = true;
        } else if(entity.vy < 0){
          // hitting head
          entity.y = (ty+1)*VW + 0.001;
          entity.vy = 0;
        }
      }
    }
  }
}

function updatePhysics(dt){
  // Player controls
  const p = player;
  // Horizontal movement
  if(keys['ArrowLeft'] || keys['KeyA']){ p.vx -= MOVE_ACC * dt; p.facing = -1; }
  else if(keys['ArrowRight'] || keys['KeyD']){ p.vx += MOVE_ACC * dt; p.facing = 1; }
  else {
    // friction
    if(p.vx > 0){ p.vx = Math.max(0, p.vx - FRICTION * dt); }
    else if(p.vx < 0){ p.vx = Math.min(0, p.vx + FRICTION * dt); }
  }
  // Clamp
  p.vx = Math.max(-MAX_RUN, Math.min(MAX_RUN, p.vx));

  // Jump
  if((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && p.onGround){ p.vy = -JUMP_FORCE; p.onGround=false; }

  // Gravity
  p.vy += GRAVITY * dt;
  if(p.vy > MAX_FALL) p.vy = MAX_FALL;

  // Apply physics and collisions
  resolveCollisions(p, dt);

  // Enemies AI & collisions
  for(const e of enemies){
    e.x += e.vx * dt;
    // simple tile check to flip
    const footY = e.y + e.h + 2;
    const aheadX = e.vx > 0 ? e.x + e.w + 2 : e.x - 2;
    const tileAhead = tileAtPixel(aheadX, footY);
    if(!isSolidTile(tileAhead)){
      e.vx *= -1;
    }
  }

  // Coin pickup
  for(const coin of coins){
    if(coin.collected) continue;
    if(aabbIntersect(p, coin)){
      coin.collected = true; p.score += 10; document.getElementById('score').textContent = 'Score: ' + p.score;
    }
  }

  // Enemy collision with player
  for(const e of enemies){
    if(aabbIntersect(p, e)){
      // if player is falling onto enemy, defeat enemy
      if(p.vy > 0 && (p.y + p.h - e.y) < 20){
        // stomp
        const idx = enemies.indexOf(e);
        enemies.splice(idx,1);
        p.vy = -JUMP_FORCE*0.5; p.score += 25; document.getElementById('score').textContent = 'Score: ' + p.score;
      } else {
        // hit - lose life and respawn
        p.lives -= 1; document.getElementById('lives').textContent = 'Lives: ' + p.lives;
        respawnPlayer();
      }
    }
  }

  // Goal check
  if(goal && aabbIntersect(p, goal)){
    // simple win
    alert('You reached the goal! Score: ' + p.score);
    location.reload();
  }
}

function respawnPlayer(){
  player.x = 64; player.y = -100; player.vx = 0; player.vy = 0;
}

function aabbIntersect(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function update(dt){
  // fixed-step integration
  accumulator += dt;
  while(accumulator >= STEP){
    updatePhysics(STEP);
    accumulator -= STEP;
  }

  // Camera follow (center on player)
  cam.x = player.x + player.w/2 - cam.w/2;
  cam.y = player.y + player.h/2 - cam.h/2;
  // clamp camera
  cam.x = Math.max(0, Math.min(cam.x, COLS*VW - cam.w));
  cam.y = Math.max(0, Math.min(cam.y, ROWS*VW - cam.h));
}

function drawGrid(){
  // draw background grass
  const cols = Math.ceil(cam.w / VW) + 2;
  const rows = Math.ceil(cam.h / VW) + 2;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      // subtle pattern (not necessary)
    }
  }
}

function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.save();
  ctx.translate(-cam.x, -cam.y);

  // draw tiles
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const t = level[r][c];
      if(t===0) continue;
      const x = c*VW, y = r*VW;
      if(t===1){
        // solid
        ctx.fillStyle = '#6b3';
        ctx.fillRect(x,y,VW,VW);
        // dirt
        ctx.fillStyle = '#6b3';
        ctx.fillRect(x,y+VW*0.6,VW,VW*0.4);
        ctx.fillStyle = '#4a3';
        ctx.fillRect(x+2,y+VW*0.6,VW-4,VW*0.4-2);
      } else if(t===2){
        // one-way platform
        ctx.fillStyle = '#9bd';
        ctx.fillRect(x+2,y+VW*0.5,VW-4,6);
      } else if(t===3){
        // coin tile - draw as tile too
        ctx.fillStyle = '#6b3'; ctx.fillRect(x,y,VW,VW);
      } else if(t===4){
        ctx.fillStyle = '#6b3'; ctx.fillRect(x,y,VW,VW);
      }
    }
  }

  // draw coins
  for(const coin of coins){
    if(coin.collected) continue;
    ctx.beginPath();
    ctx.fillStyle = 'gold';
    ctx.ellipse(coin.x+coin.w/2, coin.y+coin.h/2, coin.w/2, coin.h/2, 0,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.stroke();
  }

  // draw enemies
  for(const e of enemies){
    ctx.fillStyle = '#b33';
    ctx.fillRect(e.x, e.y, e.w, e.h);
  }

  // draw player
  ctx.save();
  const p = player;
  ctx.translate(p.x + p.w/2, p.y + p.h/2);
  ctx.scale(p.facing,1);
  // body
  ctx.fillStyle = '#044';
  ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
  // eyes
  ctx.fillStyle = '#fff'; ctx.fillRect(-8, -10, 6,6); ctx.fillRect(2, -10, 6,6);
  ctx.fillStyle = '#000'; ctx.fillRect(-6, -8, 3,3); ctx.fillRect(4, -8, 3,3);
  ctx.restore();

  ctx.restore();
}

function loop(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// initialize UI
document.getElementById('score').textContent = 'Score: 0';
document.getElementById('lives').textContent = 'Lives: 3';

requestAnimationFrame(loop);

// Helpful: expose level & editor in console for tinkering
console.log('Level and game objects available as `level`, `player`, `enemies`, `coins`. Edit `level` array to change tiles.');
</script>
</body>
</html>
